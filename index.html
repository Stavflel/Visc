<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	  <style type="text/css">
		  #container {
			  /* The CSS background works only if the renderer is set to 'alpha=true' */
			  background:-moz-linear-gradient(#ffffff, #ffffff);		/* Firefox 3.6+ */
			  background:-ms-linear-gradient(#ffffff, #ffffff);		/* Internet Explorer 10 */
			  background:-webkit-linear-gradient(#ffffff, #ffffff);	/* Safari 5.1+, Chrome 10+ */
			  background:-o-linear-gradient(#ffffff, #ffffff);		/* For Opera 11.1 to 12.0 */
			  background:linear-gradient(#ffffff, #ffffff);			/* Standard syntax */
		  }
	  </style>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" integrity="sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M" crossorigin="anonymous">
	<link rel="stylesheet" href="css/style.css" />

    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.11.0/umd/popper.min.js" integrity="sha384-b/U6ypiBEHpOf/4+1nzFpr53nxSS+GLCkfwBdFNTxtclqqenISfwAzpKaMNFNmj4" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/js/bootstrap.min.js" integrity="sha384-h0AbiXch4ZDo7tp9hKZ4TsHbi047NrKGLO3SEJAg45jXxnGIfYzk4Si90RDIqNm1" crossorigin="anonymous"></script>
  	<script src="js/three.js"></script>

	<script src="js/Detector.js"></script>
	<script src="AxisSystem.js"></script>
	<script src="CDPlayer.jt.json/models.js"></script>
  	<script src="cover.jt.json/models.js"></script>
	<script src="coverback.jt.json/models.js"></script>
	<script src="coverbacklowres.jt.json/models.js"></script>
	<script src="coverlowres.jt.json/models.js"></script>
	<script src="coverremovallowres.jt.json/models.js"></script>
	<script src="coverlowestres.jt.json/models.js"></script>
	<script src="TrackballControls.js"></script>
	<script src="CanvasRenderer.js"></script>
	<script src="Projector.js"></script>
    <script src="OrbitControls.js"></script>

  	<link href="css/bootstrap-directional-buttons.css" rel="stylesheet">
  </head>
  
  <body>
	<div class="container">
		<div class="row">
			<!-- Start Main window -->
			<div class="col-md-8 testborder">
				<!-- Used for threejs -->
				<div id="container" style="min-height:500px;"></div>

				<!-- Start bottom bar -->
				<div class="col-md-12 testborder">
				<!-- Start Menu bar -->		
					<div class="btn-group">
						<button type="button" class="btn btn-lg btn-arrow-right">Model</button>
						<button type="button" class="btn btn-lg btn-arrow-right">Interior</button>
						<button type="button" class="btn btn-lg btn-arrow-right">Exterior</button>
						<button type="button" class="btn btn-lg btn-arrow-right">Addons</button>
					</div>
				<!-- End Menu bar -->
				</div>
				<!-- Start bottom bar -->
			</div>
			<!-- End Main window -->
			
			<!-- Start Side bar -->
			<div class="col-md-4 testborder">
				<h3 class="text-center">$NameOfCar</h3>
	
				<!-- Start Config menus -->
				<div class="row nomargin">
					<div class="panel-group" id="accordion" style="width:100%;">
						<!-- Start First section -->
						<div class="panel panel-default">
							<div class="panel-heading">
								<h4 class="panel-title">
									<a data-toggle="collapse" data-parent="#accordion" href="#collapse1" id="">
										Colour	
									</a>
									<i class="fa fa-caret-down caret" data-toggle="collapse" data-parent="#accordion" href="#collapse1"></i>
									<hr class="nomargin nopadding">
								</h4>
							</div>
							<div id="collapse1" class="panel-collapse collapse show">
								<div class="panel-body">
									<table class="table">
										<tr>
											<td id="colorWhite">item1</td>
											<td id="colorBlack">item2</td>
											<td id="colorBlue">item3</td>
										
										</tr>
										<tr>
											<td id="colorRed">item4</td>
											<td id="colorGrey">item5</td>
										</tr>
									</table>
								</div>
							</div>
						</div>
						<!-- End First section -->
						<!-- Start Second section -->
						<div class="panel panel-default">
							<div class="panel-heading">
								<h4 class="panel-title">
									<a data-toggle="collapse" data-parent="#accordion" href="#collapse2">
										Rims
										<hr class="nomargin nopadding">
									</a>
								</h4>
							</div>
							<div id="collapse2" class="panel-collapse collapse">
								<div class="panel-body row text-center nopadding nomargin">
									<div class="col-md-4 col-sm-4 col-xs-4 testborder" id="side">
										hej
									</div>
									<div class="col-md-4 col-sm-4 col-xs-4 testborder" id="front">
										hej
									</div>
									<div class="col-md-4 col-sm-4 col-xs-4 testborder" id="back">
										hej
									</div>
								</div>
							</div>
						</div>
						<!-- End Second section -->
						<!-- Start Third section -->
						<div class="panel panel-default">
							<div class="panel-heading">
								<h4 class="panel-title">
									<a data-toggle="collapse" data-parent="#accordion" href="#collapse3">
										Another option
										<hr class="nomargin nopadding">
									</a>
								</h4>
							</div>
							<div id="collapse3" class="panel-collapse collapse">
								<div class="panel-body">
								</div>
							</div>
						</div>
					</div>
				</div>
				<!-- End Config menus -->
				
				<!-- Start Config nav -->
				<div class="testborder bottom col-md-12">
					<button type="button" class="btn btn-default btn-small bottom float-left">&lt; Prev</button>
					<button type="button" class="btn btn-default btn-lg float-right">Interior &gt;</button>
				</div>
				<!-- End Config nav -->
			</div>
			<!-- End Side bar -->

		</div>
	</div>

	<script>


		//TODO remove that ur able to stop rotation on change camera view animation

        var scene;
        var camera;
        var controls;
        var _controls;
        var container;
        var geometryArray;
        var currentVectorPosition = new THREE.Vector3(0,0,0);
        var setVectorPosition = new THREE.Vector3(0,0,0);
        var movingCamera;
        var viewFour;

        //Set to true to show the collision walls for each camera view
        var showCollision = false;

        //Keeps track of all camera views
        var cameraPositions;

        ///TODO GET all parts that is going to change the color with color clicked
		const bodyElements = [
            'Ejector Door [12] (2)'
		];

		//Programming color values
		const colors = {
		  	colorWhite: 0xffffff,
            colorBlack: 0x000000,
            colorBlue: 0x0000ff,
            colorRed: 0xff0000,
            colorGrey: 0x7a7a7a,
            colorAqua: 0x00ffff
		};

		//The vector for each view
		const defaultViews = {
		    side: new THREE.Vector3(175,-4,30), //TODO add right vector
			front: new THREE.Vector3(-8,-187,55), //TODO add right vector
			back: new THREE.Vector3(0, 165, 30), //TODO add right vector
			interior: "new" //TODO add right vector
		};


        //New patched framework for raycaster in three.js now working
        //with jtviewer
        var raycaster = new THREE.Raycaster();
        var newCaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(), INTERSECTED;
        initializeScene();

        animateScene();

        function initializeScene(){
            /*setTimeout(function () {
                //document.body.children[2].style.display="none";
            },10);*/

            if(!Detector.webgl){
                Detector.addGetWebGLMessage();
                return;
            }
            raycaster = new THREE.Raycaster();
            newCaster = new THREE.Raycaster();
            container = document.getElementById("container");

            containerWidth = container.clientWidth;
            containerHeight = container.clientHeight;
            renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
            renderer.setSize(containerWidth, containerHeight);
            container.appendChild(renderer.domElement);

            // Add object picking
            projector = new THREE.Projector();
            mouseVector = new THREE.Vector3();

            //Adding object on camera for colletion detection
            var cameraCube = new THREE.CubeGeometry(20,20,20,1,1,1);
            var wireMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe:true});
            movingCamera = new THREE.Mesh( cameraCube, wireMaterial );
            movingCamera.position.set(0,0,0);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, containerWidth / containerHeight, 1, 1000);
            camera.position.set(0, -20, 200);
            camera.up.set( 0, 0, 1 );

            //camera initialized
            //adding movingCamera object to the camera object
            //for tracking the collisions
            camera.lookAt(scene.position);
            //camera.add(movingCamera);
            scene.add(camera);

            var grid = new THREE.GridHelper(400,400, 0xffffff, 0x555555);
             scene.add(grid);
            _controls = new THREE.OrbitControls(camera, renderer.domElement, document);
            _controls.panSpeed = 0.8;
            _controls.noPan = false;

            initializeViewCollisions();

            geometryArray = new Object();

            //CD player
			loadJSON(jsonFileNames,numberOfJSONFiles,boundingBoxMinimum,boundingBoxMaximum);
            //Low resolution
           /* loadJSON(jsonFileNamesCoverbackLowres,numberOfJSONFilesCoverbackLowres,
				boundingBoxMinimumCoverbackLowres,boundingBoxMaximumCoverbackLowres);
            loadJSON(jsonFileNamesCoverLowestRes,numberOfJSONFilesCoverLowestRes,
				boundingBoxMinimumCoverLowestRes,boundingBoxMaximumCoverLowestRes);*/

            //Original resolution a bit laggy
            //loadJSON(jsonFileNameCover, numberOfJSONFilesCover,boundingBoxMinimumCover,boundingBoxMaximumCover);
			//loadJSON(jsonFileNameCoverback,numberOfJSONFilesCoverback,boundingBoxMinimumCoverback,boundingBoxMaximumCoverback);

            pointLight = new THREE.PointLight(0xffffff, 1.0);
            pointLight.position.copy(camera.position);
            camera.add(pointLight);
            window.addEventListener("mousemove", onMouseMove, false);
            window.addEventListener("resize", onWindowResize, false);
            _controls.addEventListener('change', render);
			addListenersToColors();
            function addListenersToColors() {
                document.getElementById("colorWhite").addEventListener("click",colorClicked);
                document.getElementById("colorBlack").addEventListener("click",colorClicked);
                document.getElementById("colorBlue").addEventListener("click",colorClicked);
                document.getElementById("colorRed").addEventListener("click",colorClicked);
                document.getElementById("colorGrey").addEventListener("click",colorClicked);
                document.getElementById("back").addEventListener("click", setNewDefaultView);
                document.getElementById("side").addEventListener("click", setNewDefaultView);
            }

        }
        function loadJSON(jsonFileNames, numberOfJSONFiles, boundingBoxMinimum,boundingBoxMaximum) {
            var scaleFactor = calculateScaleFactor(boundingBoxMinimum, boundingBoxMaximum);
            var loader = new THREE.JSONLoader();
            /**
             * Loads le json files and add a reff id _jsonLink
             * to each mesh name, so It can be trace when something is gonna
             * be changed with that specific mesh
             *
             * XD:D:D:
             * */
            for(var _json in jsonFileNames) {
              //  console.log("layerlink" + jsonFileNames[_json]);
                var _jsonLink = jsonFileNames[_json];
                (function (link) {
                    loader.load(
                        // resource URL
                        _json,
                        // onLoad callback
                        function (geometry, materials) {
                            // console.log("jaja" + link);
                            var mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
                                side: THREE.DoubleSide
                            }));
                            mesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
                            mesh.name = link;
                            scene.add(mesh);
                            geometryArray[link] = mesh;
                            if ((scene.children.length - 1) == numberOfJSONFiles) {
                                fitAll(scene);
                            }

                        },
                        // onProgress callback
                        function (xhr) {
                      //      console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                        },

                        // onError callback
                        function (err) {
                    //        console.log('An error happened');
                        }
                    );
                })(_jsonLink);
            }
        }

        // Set collision for the camera views for rotating effect
        function initializeViewCollisions(){
            cameraPositions = new Object();

            //SIDES COLLISIONS DETECTION
            var cubeSideOne = new THREE.CubeGeometry(containerWidth,2,containerHeight,2,2,2);
            var rayMaterial = new THREE.MeshBasicMaterial({color: 0x8888ff});

            var viewOne = new THREE.Mesh(cubeSideOne,rayMaterial);
            viewOne.position.set(-300,0,0);
            viewOne.rotation.y = Math.PI/2;
            viewOne.name = 'viewOne';
            viewOne.material.visible = showCollision;
            scene.add(viewOne);
            cameraPositions['viewOne'] = viewOne;

            var cubeSideTwo = new THREE.CubeGeometry(containerWidth,2,containerHeight,2,2,2);
            var rayMaterialSideTwo = new THREE.MeshBasicMaterial({color: 0x8888ff});
            var viewTwo = new THREE.Mesh(cubeSideTwo, rayMaterialSideTwo);
            viewTwo.position.set(300,0,0);
            viewTwo.rotation.y = Math.PI/2;
            viewTwo.name = 'viewTwo';
            viewTwo.material.visible = showCollision;
            scene.add(viewTwo);
            cameraPositions['viewTwo'] = viewTwo;

            //BACK AND FRONT CAMERA COLLISIONS DETECTION
            var backCube = new THREE.CubeGeometry(containerHeight,containerWidth,2,2,2,2);
            var rayMaterialBack = new THREE.MeshBasicMaterial({color: 0x8888ff});
            var viewThree = new THREE.Mesh(backCube,rayMaterialBack );
            viewThree.position.set(0,300,0);
            viewThree.rotation.y = Math.PI/2;
            viewThree.name = 'viewThree';
            viewThree.material.visible = showCollision;
            scene.add(viewThree);
            cameraPositions['viewThree'] = viewThree;

            var frontCube = new THREE.CubeGeometry(containerHeight,containerWidth,2,2,2,2);
            var rayMaterialFront = new THREE.MeshBasicMaterial({color: 0x8888ff});
            viewFour = new THREE.Mesh(frontCube,rayMaterialFront  );
            viewFour.position.set(0,-300, 0);
            viewFour.rotation.y = Math.PI/2;
            viewFour.name = 'viewFour';
            viewFour.material.visible = showCollision;
            scene.add(viewFour);
            cameraPositions['viewFour'] = viewFour;

            console.log("check is it a mesh= " + cameraPositions['viewFour'].isMesh);

        }
        //TODO get all ids that going to change on a click
        function colorClicked(event){
			for(var i = 0; i < bodyElements.length; i+=1){
			    if(bodyElements[i] !== undefined){
					geometryArray[bodyElements[i]].material.color.setHex(colors[event.target.id] );
					break;
				}
			}
		}
		function setNewDefaultView(event) {
            if(event.target.id === 'back'){
                console.log("Lolish clickish?");
               // _controls.autoRotate = true;
               // var vector = new THREE.Vector2(347,251);
               // _controls.rotateOnGivenPoint(vector);

            }else if(event.target.id === 'side') {
                console.log("le click side?? ");
                //_controls.target.set(defaultViews.side);
            }
        }

        function onWindowResize(resizeEvent){
            renderer.setSize(container.clientWidth, container.clientHeight);
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
        }

        function onMouseMove(event){
            event.preventDefault();
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }

        //TODO add rotation around x axis only
        function setForOnlyNavigationAroundXAxis() {
            _controls.minPolarAngle = Math.PI;
            _controls.maxPolarAngle = Math.PI/2;
        }


        /**
         * Scale each mesh based on vertexs in each json that being loaded.
         * */
        function calculateScaleFactor(boundingBoxMinimum, boundingBoxMaximum){
            // Get bounding box size
            var bBoxSize = [(boundingBoxMaximum[0] - boundingBoxMinimum[0]),
				(boundingBoxMaximum[1] - boundingBoxMinimum[1]),
				(boundingBoxMaximum[2] - boundingBoxMinimum[2])];
            // Detect largest dimension
            var largestSize = bBoxSize[0];
            if(bBoxSize[1] > largestSize){
                largestSize = bBoxSize[1];
            }
            if(bBoxSize[2] > largestSize){
                largestSize = bBoxSize[2];
            }

            // Scale dimension to 100
            return 100.0 / largestSize;
        }

        /**
         * Fit the content together in the scene
         * */
        function fitAll(node){
            // Calculate bounding box of the whole scene
            var boundingBoxOfNode = new THREE.Box3().setFromObject(node);
            var centerOfGravity = boundingBoxOfNode.center();
            var newCameraPosition = new THREE.Vector3();
            newCameraPosition.subVectors(centerOfGravity, _controls.target);
            camera.position.addVectors(camera.position, newCameraPosition);
            camera.lookAt(centerOfGravity);
            _controls.target.set(centerOfGravity.x, centerOfGravity.y, centerOfGravity.z);

            // Move camera along z until the object fits into the screen
            var sphereSize = boundingBoxOfNode.size().length() * 0.5;
            var distToCenter = sphereSize / Math.sin(Math.PI / 180.0 * camera.fov * 0.5);
            var target = _controls.target;
            var vec = new THREE.Vector3();
            vec.subVectors(camera.position, target);
            vec.setLength(distToCenter);
            camera.position.addVectors(vec , target);
        }

        function animateScene(){
            _controls.update();
            requestAnimationFrame(animateScene);
            renderScene();
        }
        function renderScene(){
            render();
            renderer.render(scene, camera);
        }
        function render() {
            camera.updateMatrixWorld();
            currentVectorPosition.set(camera.position.x, camera.position.y, camera.position.z);
            checkCollision();
            renderer.render(scene, camera);
        }
        //TODO fix ray cast so it only hits one time at the intersection point
        function checkCollision(){
            //Add a zero plane which cast from the current
			//camera direction towards the center of gravity
            var zeroPlane = new THREE.Vector3(0,0,0);
            raycaster.setFromCamera( zeroPlane, camera);
            var intersects = raycaster.intersectObjects(scene.children);
            if(intersects.length > 0){
				for (var i = 0; i < intersects.length; i += 1) {
					if (intersects[i] !== undefined) {
						if(intersects[ i ].object.name  ===  ('viewFour') && i !== 0){ //Back view
						    console.log("lol??" + i);
						}else if( intersects[ i ].object.name === ('viewThree') && i !== 0){ //Front view
						  	console.log("Hit view three: " + i);
                            _controls.autoRotate = false;
                        }else if(intersects[ i ].object.name === ('viewTwo') && i !== 0){ // Side left view
                            console.log("Hit view two: " + i);
						}else if(intersects[ i ].object.name === ('viewOne') && i !== 0){ // Side right view
                            console.log("Hit view one: " + i);
						}
					}
				}
            }
        }
	</script>
  </body>
</html>